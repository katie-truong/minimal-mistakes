---
layout: single
title: "Explore the world of Pokemons"
description: "My attempt to make interactive plots using dplyr, tidyr, ggplot2 and plotly"
category: R
tags: [r, pokemon, plotly, ggplot2, interactive plot, dplyr, tidyr]
comments: true
---

When it comes to Pokemons, there are two big sorts of Pokemons: the single ones (pokemons of only one type) and the dual ones (pokemons with two types). The majority of starter pokemons (except for Bulbasaur and Charmander) tend to be of single type, while many pokemons later in the game tend to be of dual types. However, there are exceptions, such as Mewtwo and one of its elvolved state, MewtwoMega Mewtwo Y, are of pure single type. So what is the secret behind the Single and Dual mechanism of pokemons? In this post, I would use the Hadley Wickham's packages (`dplyr` and `tidyr`) along with `ggplot2` to analyze and visualize a Pokemon dataset, which would hopefully figure out what sort of pokemons are better: single type or dual type?

## Preliminary steps

First, we need to load the file from the source, and load all the libraries we would use in the analysis:

```
pokemons_wide <- read.csv("Pokemon.csv")
library(ggplot2)
library(plotly)
library(dplyr)
library(tidyr)
library(scales)
```

Using the `str` function for the dataset, we can see the very clean and straightforward structure of the dataset:

```
str(pokemons_wide)

'data.frame':	800 obs. of  13 variables:
 $ X.        : int  1 2 3 3 4 5 6 6 6 7 ...
 $ Name      : Factor w/ 800 levels "Abomasnow","AbomasnowMega Abomasnow",..: 81 330 746 747 103 104 100 101 102 666 ...
 $ Type.1    : Factor w/ 18 levels "Bug","Dark","Dragon",..: 10 10 10 10 7 7 7 7 7 18 ...
 $ Type.2    : Factor w/ 19 levels "","Bug","Dark",..: 15 15 15 15 1 1 9 4 9 1 ...
 $ Total     : int  318 405 525 625 309 405 534 634 634 314 ...
 $ HP        : int  45 60 80 80 39 58 78 78 78 44 ...
 $ Attack    : int  49 62 82 100 52 64 84 130 104 48 ...
 $ Defense   : int  49 63 83 123 43 58 78 111 78 65 ...
 $ Sp..Atk   : int  65 80 100 122 60 80 109 130 159 50 ...
 $ Sp..Def   : int  65 80 100 120 50 65 85 85 115 64 ...
 $ Speed     : int  45 60 80 80 65 80 100 100 100 43 ...
 $ Generation: int  1 1 1 1 1 1 1 1 1 1 ...
 $ Legendary : Factor w/ 2 levels "False","True": 1 1 1 1 1 1 1 1 1 1 ...
 
```

 
 The dataset has 800 rows (yes, 800 different pokemons!) with 13 basic variables including their IDs, names, types, stats, generation and whether if they are legendary pokemons or not. Looking at the source, each column is explained as followed:
 
 
    #: ID for each pokemon
    Name: Name of each pokemon
    Type 1: Each pokemon has a type, this determines weakness/resistance to attacks
    Type 2: Some pokemon are dual type and have 2
    Total: sum of all stats that come after this, a general guide to how strong a pokemon is
    HP: hit points, or health, defines how much damage a pokemon can withstand before fainting
    Attack: the base modifier for normal attacks (eg. Scratch, Punch)
    Defense: the base damage resistance against normal attacks
    SP Atk: special attack, the base modifier for special attacks (e.g. fire blast, bubble beam)
    SP Def: the base damage resistance against special attacks
    Speed: determines which pokemon attacks first each round

We can notice that there are many empty Type.2 in the dataset. These are single-type pokemons. We can sort the pokemons into these two types by using the `ifelse` function:


```
pokemons_wide$Sort <- ifelse(pokemons_data$Type.2 == "", "Single", "Dual")
```

Another step we should do is to melt **Type.1** and **Type.2** into one column as **Type** for easier analysis in the next section and rearrange the dataset into a nice, usable format. We can achieve that easily by using `dplyr` and `tidyr`:

```
# Sort into Single or Dual Type
pokemons_wide$Sort <- ifelse(pokemons_data$Type.2 == "", "Single", "Dual")

# Melt Type1 and Type2 into Type
pokemons_long <- gather(pokemons_wide, Category, Type, 
                   Type.1, Type.2, factor_key = T)

# Convert to tbl_df
pokemons_long <- tbl_df(pokemons)

# Deselect the empty type 2
pokemons_long <- filter(pokemons_long, Type != "")

# Order by Poke number
pokemons_long <- pokemons_long[order(pokemons_long$X., pokemons_long$Category), ]

# Select usable columns
pokemons_long <- select(pokemons_long, Name, Type, Sort, Total:Legendary)
```

Which would give us a nice, clean long dataframe of 1214 rows and 12 columns:

```
> pokemons_long
Source: local data frame [1,214 x 12]

                    Name   Type   Sort Total    HP Attack Defense Sp..Atk Sp..Def Speed Generation Legendary
                  (fctr)  (chr)  (chr) (int) (int)  (int)   (int)   (int)   (int) (int)      (int)    (fctr)
1              Bulbasaur  Grass   Dual   318    45     49      49      65      65    45          1     False
2              Bulbasaur Poison   Dual   318    45     49      49      65      65    45          1     False
3                Ivysaur  Grass   Dual   405    60     62      63      80      80    60          1     False
4                Ivysaur Poison   Dual   405    60     62      63      80      80    60          1     False
5               Venusaur  Grass   Dual   525    80     82      83     100     100    80          1     False
6  VenusaurMega Venusaur  Grass   Dual   625    80    100     123     122     120    80          1     False
7               Venusaur Poison   Dual   525    80     82      83     100     100    80          1     False
8  VenusaurMega Venusaur Poison   Dual   625    80    100     123     122     120    80          1     False
9             Charmander   Fire Single   309    39     52      43      60      50    65          1     False
10            Charmeleon   Fire Single   405    58     64      58      80      65    80          1     False
..                   ...    ...    ...   ...   ...    ...     ...     ...     ...   ...        ...       ...
```

In this analysis, we would be working on both the origional **pokemons_wide** and the gathered format **pokemons_long**, depends on the task we are doing.
